# Algorithms

Repo for algorithms and data structures on Java

### Жадные алгоритмы
Жадные алгоритмы как правило решают оптимизационные задачи и на каждом шаге делают некоторый 
наиболее очевидный шаг, так называемый жадный шаг, таким образом строят оптимальное решение.

#### Пример. Покрытие точек отрезками.
Есть множество n точек на прямой. Необходимо покрыть все точки 
минимальным количеством отрезков единичной длины.    
Надежный шаг - это добавить отрезок, левый конец которого совпадает с самой крайней левой точкой.
Мы заранее знаем, что это оптимальный шаг. Так как есть множество оптимальных решений, то мы 
выбираем одно из них, которе описано в надежном шаге.    
Решение - выполнять надежный шаг на каждой итерации цикла, при этом забывая те точки которые 
покрыли отрезком. 
Сложность O(n^2)


#### Пример. Необходимо взять максимальное количество вершин не соединенных ребром.
Надежный шаг - существует оптимальное решение, которое содержит все листья дерева, то есть все 
вершины, у которых нет, дочерних вершин.

#### Пример. Задача о непрерывном рюкзаке
Есть веса w1...wn и стоимости предметов c1...cn. А так же вместимость рюкзака W. Необходимо 
узнать суммарную стоимость ЧАСТЕЙ всех предметов в рюкзаке, вес которых не превышает W. То есть 
можно предмет разделить на часть, при этом стоимость и вес его пропорционально изменятся.    
Надежный шаг - существует оптимальное решение, содержащее максимально возможную часть предмета, 
**стоимость которого за килограмм максимальна**. То есть надо использовать по максимома самый 
дорогой предмет.

#### Коды Хаффмана
Оптимальный бинарный код для сжатия строки.

##### Пример.
На вход подается строка и мы хотим каждому ее символу присвоить бинарный код так, что бы после 
того как каждый символ заменили на его бинарный код получилась как можно более короткая бинарная 
строчка. Оптимизация - попытаться часто используемому символу присвоить более короткий код.
Свойство - код называется **беспрефиксными**, если никакой код символа не является префиксом другого 
кода символа. Это значит, что ни один код символа не является префиксом кода другого символа, 
таким образом когда мы будем читать коды мы всега однозначно будем понимать, что это за символ. 
Беспрефиксными коды удобно представлять в двоичном дереве.    
Частота некорневой вершины назовем количество раз, которое вершина будет посещена в процессе 
кодировки\декодировки. Таким оразом мы ищем строго двоичное дерево с минимальной суммой пометок 
в вершинах, в котором листья помечены входными частотами, а внутренние вершины - суммами 
пометок их детей. Две минимальные частоты будут листьями на самом нижнем уровне и можно считать, 
что они братья. Надежный шаг - выбрать две минимальные частоты fi и fj, сделать их детьми новой 
вершины с пометкой fi+fj; выкинуть частоты fi и fj, добавить fi + fj.

